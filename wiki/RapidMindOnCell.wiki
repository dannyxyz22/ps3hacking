Benchmarking between a parallel program and a non-parallel program running on Cell processor with RapidMind

= Introduction =
Neste wiki será feita uma comparação entre o desempenho do Cell e de um processador convencional. Para isso, será realizada a soma de vários números conforme mostrado abaixo: 

|| inputArray || outputArray ||
|| { {0, 1, 2} , {1, 2, 3} } ||	{(0+1+2) = 3, (1+2+3) = 6 } ||
|| { {1, 2, 3} , {2, 3, 4} } ||	{(1+2+3) = 6, (2+3+4) = 9 } ||
|| { {2, 3, 4} , {3, 4, 5} } ||	{(2+3+4) = 9, (3+4+5) = 12} ||
|| ... || ... ||

Essa operação será realizada várias vezes repetidamente para tornar o cálculo mais custoso e, dessa forma, aumentar o tempo de execução do programa e facilitar a comparação de desempenho.

= Procedimento =
=== Instalação do RapidMind ===
O RapidMind foi baixado deste [https://developer.rapidmind.net/downloads/2.0/cellbe/ site]. O arquivo instalado foi o [https://developer.rapidmind.net/downloads/2.0/cellbe/rapidmind-platform-cell-2.0.0.6546-cellsdk20.ppc.rpm/ RapidMind 2.0 for Cell BE SDK 2.0].
Para realizar a instalação, basta digitar na linha de comando
_rpm -ivh arquivo.rpm_, onde _arquivo_ é o nome do arquivo a ser instalado.
O hardware utilizado é um Playstation 3 rodando Yellow Dog Linux.

=== Códigos-Fonte ===
Foram utilizados dois códigos-fonte. Um deles realiza as operações de forma não-paralelizada (_NonParallelSum_), como qualquer processador faria. No Cell, ele é executado apenas na PPU. O outro código é paralelizado (_ParallelSum_) e executado usando tanto a PPU quanto as SPUs. A paralelização foi feita usando funções do RapidMind, conforme tutorias disponíveis [https://developer.rapidmind.net/tutorials aqui]. Ambos os códigos estão disponíveis [http://ps3hacking.googlecode.com/files/RapidMindOnCellCodes.rar neste link]. 

=== Compilação dos códigos-fonte ===
Para compilar os códigos, foi utilizado o seguinte comando:
_g++ -lrmplatform code.cpp –o code –O3_
bastando substituir _code_ por _ParallelSum_ ou _NonParallelSum_. A expressão _-lrmplatform_ indica que a biblioteca do RapidMind deve ser utilizada e _–O3_ indica o maior nível de otimização.

= Resultados =
Os dois programas foram executados para vários valores de _vezes_. Os resultados estão mostrados na tabela e gráfico a seguir.

|| _vezes_ || ParallelSum time (ms) || NonParallelSum time (ms) ||
|| 1 ||	145 || 10.9 ||
|| 5 ||	148 || 51.2 ||
|| 10 || 153 || 98.1 ||
|| 50 || 184 || 486.0 ||
|| 100 || 221 || 982.3 ||
|| 500 || 530 || 4898.9 ||
|| 1000 || 882 || 9719.4 ||
|| 5000 || 3.973 || 48544.8 ||
|| 10000 || 7762,42 || 97164.4 ||
|| 50000 || 37.917 || 494354.0 ||

http://ps3hacking.googlecode.com/files/WikiRapidmind.JPG

Pode-se perceber que para valores pequenos de _vezes_, i.e., baixo volume de cálculos, o Cell fica em desvantagem com relação aos processadores comuns. Isso ocorre porque o RapidMind leva um certo tempo para inicializar suas funções e esse tempo não é compensado se o volume de operações não for grande o suficiente.
Para descobrir esse tempo de inicialização, foram feitos 10 loops no trecho do código em que as funções do RapidMind são chamadas e foi medido o tempo de execução de cada loop. O resultado está mostrado na tabela abaixo:

|| 1º loop || 143.289 milliseconds. ||
|| 2º loop || 0.911 milliseconds. ||
|| 3º loop || 0.800 milliseconds. ||
|| 4º loop || 0.763 milliseconds. ||
|| 5º loop || 0.788 milliseconds. ||
|| 6º loop || 0.769 milliseconds. ||
|| 7º loop || 0.756 milliseconds. ||
|| 8º loop || 0.780 milliseconds. ||
|| 9º loop ||0.775 milliseconds. ||
|| 10º loop || 0.756 milliseconds. ||

Ou seja, as funções do RapidMind levam cerca de 140 milliseconds para serem carregadas e isso ocorre apenas no primeiro loop. Nos loops seguintes, o tempo de execução é menor do que 1 millisecond.

Portanto, pode-se concluir que para valores de _vezes_ maiores que 1000, para os quais o tempo de inicialização é menor que 10% do tempo total de execução, o Cell realiza os cálculos deste exemplo 10 vezes mais rápido que um processador comum, que opera em paralelo.