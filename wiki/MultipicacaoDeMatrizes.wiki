#summary Tempo de execução de um programa serial x paralelo.

= Objetivo =

Verificar o ganho de tempo do processamento paralelo nas SPEs do Cell em relação ao processamento apenas num PPE. Será realizada a multiplicação de duas matrizes 100000 vezes, para que mesmo usando matrizes pequenas, o ganho de tempo de execução possa ser observado.


= Códigos e Comentários =

Serão utilizadas matrizes 8x8, para que cada SPE seja responsável pelo resultado de uma linha da matriz final.

O código abaixo realiza a multiplicação de matrizes da forma convencional, apenas PPE, e mostra o tempo de execução.

{{{
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define SPE_THREADS 8

typedef struct
{
    int vezes, n, p, num;
    float linmat1[SPE_THREADS];
    float mat2[SPE_THREADS][SPE_THREADS];
    float linresult[SPE_THREADS];
} __attribute__((aligned(128))) context;



int main(
{
    clock_t start, end;
    double elapsed;

    context ctxs[SPE_THREADS];
    int i, j, k, l, m, n, p, vezes=100000;

    scanf("%d %d %d", &m, &n, &p); //mat1(m x n) mat2(n x p) mat3(m x p)
    m = n = p = SPE_THREADS;

    //le mat1
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            scanf("%f", &ctxs[i].linmat1[j]);

    //le mat2
    for(j=0; j<n; j++)
        for(k=0; k<p; k++)
            scanf("%f", &ctxs[0].mat2[j][k]);

    start = clock();
    //processamento
    for(l=0; l<vezes;l++)
    {
        for(i=0; i<m; i++)
            for(j=0; j<p; j++)
                ctxs[i].linresult[j]=0;

        for(i=0; i<m; i++)
            for(j=0; j<n; j++)
                for(k=0; k<p; k++)
                    ctxs[i].linresult[k] += ctxs[i].linmat1[j]*ctxs[0].mat2[j][k];
    }

    //imprime a matriz resultado
    for(i=0; i<m; i++, printf("\n"))
        for(j=0; j<p; j++)
            printf("%.2f ", ctxs[i].linresult[j]);

    //calcula e imprime o tempo de execução
    end = clock();
    elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Tempo de execucao: %f\n",elapsed);

    return 0;
}
}}}

A estrutura
{{{
typedef struct
{
    int vezes, n, p, num;
    float linmat1[SPE_THREADS];
    float mat2[SPE_THREADS][SPE_THREADS];
    float linresult[SPE_THREADS];
} __attribute__((aligned(128))) context;
}}}
será utilizada tanto no processamento PPE quanto SPE, mas a variável _vezes_ e o comando _ __attribute__((aligned(128))) context_ serão usados apenas no SPE.

A seguir serão mostrados os programas PPE, que distribuirá o “trabalho” entre as SPEs, e SPE, que realiza o cálculo propriamente dito.

== Programa PPE ==
{{{
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <libspe.h>

extern spe_program_handle_t matrix_spu;

typedef struct
{
    int vezes, n, p, num;
    float linmat1[SPE_THREADS];
    float mat2[SPE_THREADS][SPE_THREADS];
    float linresult[SPE_THREADS];
} __attribute__((aligned(128))) context;

int main()
{
    int i, j, k, status, m, n, p, vezes=1;
    clock_t start, end;
    double elapsed;
    start = clock();  //inicia a contagem do tempo

    scanf("%d %d %d", &m, &n, &p); //mat1(m x n) mat2(n x p) mat3(m x p)
    m = n = p = SPE_THREADS; //deixamos o tamanho fixo em 8x8

    context ctxs[m]; //cria o vetor de "contextos"

    //le a matriz1, com uma linha para cada "contexto"
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
    scanf("%f", &ctxs[i].linmat1[j]);

    //le a matriz2, com cada "contexto" possuindo uma copia completa da mesma
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            for(k=0; k<p; k++)
                if(i==0) scanf("%f", &ctxs[0].mat2[j][k]);
                else ctxs[i].mat2[j][k]=ctxs[0].mat2[j][k];

    //inicia as threads para cada SPE, enviando os dados necessarios
    speid_t spe_ids[m];
    for(i=0; i<m; i++)
    {
        ctxs[i].num = i;
        ctxs[i].vezes = vezes;
        ctxs[i].n = n;
        ctxs[i].p = p;
        spe_ids[i] = spe_create_thread(0, &matrix_spu, &ctxs[i], NULL, -1, 0);
        if (spe_ids[i] == 0)
        {
            fprintf(stderr, "Failed spe_create_thread(rc=%d, errno=%d)\n",
            spe_ids[i], errno);
            exit(1);
        }
    }

    // espera pela execucao completa de cada SPU-thread
    for (i=0; i<m; i++)
        (void)spe_wait(spe_ids[i], &status, 0);

    //imprime a matriz resultado
    for(i=0; i<m; i++, printf("\n"))
        for(j=0; j<p; j++)
            printf("%f ", ctxs[i].linresult[j]);

    //calcula e imprime o tempo de execucao
    end = clock();
    elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Tempo de execucao: %f\n",elapsed);
    return 0;
}
}}}